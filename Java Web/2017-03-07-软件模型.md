---
layout: post
title: "软件模型"
description: "软件模型"
date: 2017-03-07
tags: []
category: 
last_updated: 2017-08-04
comments: true
chare: true
---

* Kramdown table of contents
{:toc .toc}





# 软件模型


>《精通Hibernate：Java对象持久化技术详解》的**第一章** ：Java应用分层架构及软件模型
>什么是中间件？什么是Java对象的持久化？什么是持久化层？什么是书籍访问细节？什么是ORM？什么是域模型？什么是关系数据模型？


## Java应用分层架构及软件模型


### 1.1应用程序的分层体系结构

软件的分层必须符合以下特征：

- 每个层由一组相关的类或组件构成，共同完成特定的功能
- 层与层之间存在**自上而下的依赖**关系，即上层组件会访问下层组件的API，而下层组件不应该依赖上层组件。（**不存在这种依赖关系就不算分层**，可能就是并列）
- 每个层对上层公开API



Java应用的持久化层：

持久化层封装了数据访问细节，为业务逻辑层提供了面向对象的API。

在持久化层领域的ORM软件具有中间件的特性。
**中间件**是在应用程序和其他软件系统之间的连接管道。Hibernate可看成是连接Java应用和关系数据库的管道。


### 1.2软件的模型

在软件开发领域，模型用来表示真实世界的实体。在软件开发的不同阶段，需要为目标系统创建不同类型的模型。

分析阶段： 概念模型
设计阶段： 域模型，数据模型

![3种模型之间的关系.png](https://ooo.0o0.ooo/2017/02/26/58b257979a5c7.png)

#### 概念模型

概念模型用来模拟问题域中的真实实体。概念模型描述了每个实体的概念和属性，以及实体之间的关系。这个阶段并不描述实体的行为。

不管是技术人员还是非技术人员都能看懂概念模型，这样就可在软件设计和开发周期中越早发现问题。

实体与实体之间存在3中关系：一对一、一对多、多对多。

#### 关系数据模型

**关系数据模型**是在概念模型的基础上建立起来的，用于描述这些关系数据库的**静态结构**。



> 注意：数据库Schema有两种含义，一种是概念上的Schema，指一组DDL语句集，该语句集完整的描述了数据库的结构。
> 还有一种是物理上的Schema，指的是数据库中的一个名字空间，它包含一组表、视图、和存储过程等命名对象。

> 另见《Oracle入门很简单》中的第2章：实体-联系模型（E-R模型）
> **E-R模型到关系模型**，E-R图用于描述实体及实体间的联系，E-R图最终需要转换为关系模型才有意义。【见笔记 E-R模型】


#### 域模型

它帮助开发人员对应用的需求获得清晰、精确的理解。需要对概念模型的基础上创建域模型，域模型是面向对象的。

域模型由以下内容组成：

- 具有状态和行为的**域对象**(Domain Object)
- 域对象之间的**关系**

> 感觉 域对象对应E-R模型中的实体，域对象之间的关系对应E-R模型中的联系。好像又不是。域对象中的实体域对象对应E-R模型中的实体；域对象之间的关系中的关联对应E-R模型中的联系；看起来更像。

> 在关系数据模型中，表之间只存在外键参照关系，有点类似域模型中多对一或一对一的映射关系。(更精确的说法)


#### 域对象

域对象是对真实世界的实体的软件抽象。也可叫做业务对象（Business Object，BO）

**1.实体域对象**     

通常可以把业务领域中的**名词**作为实体域对象。
在J2EE应用中，实体EJB。
非J2EE应用中，这些名词可以**作为**包含状态和行为的**JavaBean**。采用JavaBean形式的实体域对象也称为POJO（Plain Old Java Object）

为了使实体域对象与关系数据库表中的记录对应，可以为每个实体域对象分配唯一的OID（Object Identifier，即对象标识符），它对应与关系数据库表中的主键。

**2.过程域对象**    

过程域对象代表应用中的业务逻辑或流程。它们通常依赖于实体域对象。可以把业务领域中的**动词**作为过程域对象。

在非J2EE应用中，它们可以**作为**常规的**JavaBean**，具有管理和控制应用的行为。

**3.事件域对象**     

事件域对象代表应用中的一些事件。这些事件通常由系统中的某种行为触发。

在三层应用结构中，以上3种域对象都位于业务逻辑层，**实体域对象**是应用的**业务数据**在内存中的表现形式，而**过程域对象**用于执行业务逻辑。



#### 域对象之间的关系

对比UML，和数据库中的 实体-联系模型（E-R模型）。**这一节非常重要**，详见书中代码示例。

**非常重要**
**非常重要**
**非常重要**


在域模型中，**类之间**存在4种关系。

重点关注各个类之间是如何操作的。

**1.关联（Association）：**    

关联指类之间的引用关系。这是**实体域对象**之间最普遍的一种关系。关联可以分为一对一、一对多、多对多关联（与数据库一样）。
关联是有方向的，且分为：

- 单向关联：比如**只**建立从A到B之间的多对一关联，**或者只**建立从B到A之间的一对多关联。
- 双向关联：比如建立从A到B之间的多对一关联，**又**建立从B到A之间的一对多关联。







![实体域对象之间的关联.png](https://ooo.0o0.ooo/2017/02/26/58b294b615802.png)







**2.依赖（Dependency）**     

依赖指的是类之间的访问关系。如果类A访问类B的属性或方法，或者类A负责实例化类B，那么可以说类A依赖类B。和关联不同，无需把类B定义为类A的属性。
依赖关系在(多个)实体域对象之间不常见，但是**过程域对象**往往**依赖实体域对象**，因为过程域对象会创建实体域对象，或者会访问实体域对象的属性及方法。







**3.聚集（Aggregation）**    

聚集指的是整体与部分之间的关系，在**实体域对象**之间也很常见。例如，人与手就是聚集关系。
聚集关系和关联关系在类的定义上有相同的形式，不过两者有不同的语义。对于聚集关系，部分类的对象不能单独存在，它的生命周期依赖于整体类的对象的生命周期，当整体消失，部分也随之消失。

聚集关系和关联关系在语义上的区别是由业务逻辑来决定的，通常由过程域对象来实现。




![实体域对象之间的聚集关系.png](https://ooo.0o0.ooo/2017/02/26/58b2985880796.png)

**4.一般化（Generalization）**    

一般化是指类之间的继承关系。





#### 域对象的持久化概念

对比前面介绍的域模型和关系数据模型，可以看出业务数据有两种表现形式：

- 在内存中表现为实体域对象，以及实体域对象之间的各种关系
- 在关系数据库中表现为表，以及表与表之间的参照关系

当Java程序在内存中创建了实体域对象后，它们不可能永远存在。最后它们要么从内存中清除，要么被持久化到数据存储设备中。

通常不是所有的域对象都需要持久化，通常只有实体域对象才需要持久化，而过程域对象不需要持久化。另外，有些实体域对象也不需要持久化，比如ShoppingCart对象。


本书将把需要被持久化的实体域对象所属的类统称为持久化类。


狭义的理解，“持久化”仅指把域对象永久保存到数据库中；广义的理解，“持久化”包括和数据库相关的各种操作：

- 保存：把域对象永久的保存到数据库中
- 更新：更新数据库中域对象的状态
- 删除：从数据库删除一个域对象
- 加载：根据特定的OID，把一个域对象从数据库加载到内存中
- 查询：根据特定的查询条件，把符合查询条件的一个或多个域对象从数据库加载到内存中。



