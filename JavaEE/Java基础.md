# Java基础


- 实例变量：声明在一个类中，但在方法和语句块之外声明
- 静态变量（类变量）：在类中以static修饰符声明，但必须在方法和语句块之外声明
- 局部变量：在类中某方法中声明




## 继承

### 方法覆盖与方法重载

两者的几个不同之处：  

- 方法覆盖要求签名必须一致，而方法重载要求参数签名必须不一致
- 方法覆盖要求返回类型必须一致，而方法重载对此不做限制
- 方法覆盖对方法的访问权限和抛出的异常有特殊的要求，而方法重载没有要求


### super和this关键字

super和this关键字都可以用来覆盖Java语言的默认作用域，是被屏蔽的方法或变量变为可见。

方法或变量变被屏蔽的场合：  

- 场合一：在一个方法内，当局部变量和类的成员变量同名，或局部变量和父类的成员变量同名，安装变量作用域规则，只有局部变量在方法内可见。
- 场合二： 方子类的某个方法覆盖了父类的一个方法，在子类的范围内，父类的方法不可见。
- 场合三：当子类中定义了和父类同名的成员变量时，在子类的范围内，父类的成员变量不可见。

**注意：**  
只能在构造方法或实例方法内使用super关键字，而在静态方法和静态代码块内不能使用super关键字。



### 多态

动态绑定，向上、向下转型



### final
final常量

- final修饰的类不能被继承
- final修饰的方法不能被子类的方法覆盖
- final修饰的变量表示常量，只能被赋值一次
- final不用来修饰构造方法，因为父类的构造方法和子类的构造方法不存在覆盖关系
- private修饰的方法不能被子类覆盖，因此默认也是final的。
- 对于final类型的实例变量，可以在定义变量时，或者在构造方法中进行初始化。





### abstract修饰符
abstract可用来修饰类和成员方法。

抽象方法，抽象方法没有方法体。

- 抽象类中可以没有抽象方法，但包含了抽象方法的类必须被定义为抽象类。如果子类没有实现父类中的抽象方法，那么子类也必须被定义为抽象类。
- 构造方法、静态方法不能是抽象方法。但**抽象类**中可以有非抽象的静态方法和非抽象的构造方法。
- 抽象方法和抽象类不能被final修饰符修饰。（final修饰的类不能有子类，final修饰的方法不允许被子类方法覆盖）
- 抽象方法没有方法体。





## interface

接口对其成员变量和方法做了很多限制，**接口的特征**如下：  

1. 接口中的**成员变量**默认都是public、static、final 类型的，必须被显示初始化。
2. 接口中的**方法**默认都是public、abstract类型的
3. 接口中只能包含上面两种类型的成员或方法。
4. 接口没有构造方法（也不能有）
5. 一个接口不能实现另一个接口，但它能继承**多个**其他接口。例如：A、B都是接口，`public interface C extends A,B{//}`
6. 接口**必须**通过**类**来实现它的抽象方法。
7. 与子类继承抽象父类相似，当类实现了某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。
8. 不允许创建接口的实例，但允许定义接口类型的引用变量，该变量引用实现了这个接口的类的实例。
9. 一个类只能继承一个直接的父类，但能实现多个接口。


![](https://www.javatpoint.com/images/core/interfacerelation.jpg)  



> **Java 8新特性：**  

> Java 8之前interface中的方法不能有方法体。从Java 8开始interface方法可以有方法体，但是需要使用关键字`default`将其指定为默认方法。   
>
> Since Java 8, we can have static method in interface.   

> 补充：  
> marker or tagged interface(标记或标记接口): 一个没有任何成员(方法)的接口。An interface that have no member is known as marker or tagged interface. For example: Serializable, Cloneable, Remote etc. They are used to provide some essential information to the JVM so that JVM may perform some useful operation.
>
> 内嵌的interface：interface中可以内嵌interface



![](https://www.javatpoint.com/images/core/multipleinheritance.jpg)




抽象类与接口主要的两大区别：

- 在抽象类中可以为部分方法提供默认的实现，从而避免在子类中重复实现它们，提高代码的可重用性；而接口中只能包含抽象方法。接口一旦被公布，就必须非常稳定，因为随意在接口中添加抽象方法，会影响到所有的实现类。
- 一个类可以实现(或继承)多个接口，但只能继承一个抽象类。


> 为什么Java不允许一个类有多个直接的父类？而可以实现多个接口？ 见《Java面向对象编程》P223






