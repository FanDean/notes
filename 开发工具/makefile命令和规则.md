makefile命令和规则
====================

标签：开发工具

---

命令
--------

|   命令				| 描述						|
|------------------------| ------------------------|
| make					| 将查找makefle 或 Makefile |
|-f fileName			 | 指定文件文件作为makefile文件		|
|-k						| 发现错误仍然继续执行，而不是停止 |
|-n						| 让make输出要执行的操作		|
|-s						|执行时不打印命令名，(执行而不显示执行状况) |
|-w						| 如果make在执行时改变目录，打印当前目录名|
|-r						| 禁止使用所有的内置规则  |
|-Wfile					| 如果file已经修改，则使用-n来显示将要执行的命令 |
|-d						| 打印调试信息 ，（Debug模式，输出有关文件和检测时间的详细信息      |
|-I dirname				|指定被包含的makefile所在目录  |
|-i						| 忽略makefile规则中的Linux命令返回的非零错误码，make继续执行|
|-k						|如果某个目标编译失败，继续编译其他目标|
|-jN					|每次运行N条命令|
|-p						|  打印出Makefile中所有宏定义和描述内部规则的相关行  |
| -c dir				| 在读取Makefile之前改变到指定的目录   |





规则
-------

Makefile规则通用形式：

```makefile
target: dependency [dependency [...]]
	command						
	command			#每一个命令前必须有一个制表符
	[...]
```



`\`  用处与shell中的类似

`#` 注释




用于程序名和标志的预定义变量：

| 变量  |  说明      |
|-------|--------------|
|AR		|归档维护程序，默认 = ar |
|AS		|汇编程序，默认 = as	|
|CC		| C编译程序，默认 = cc |
|CPP    |C预处理程序，默认 = cpp |
|RM		|文件删除程序，默认 = "rm -f" |
|ARFLAGS|传给归档维护程序的标志 默认 =rv |
|ASFLAGS | 传给汇编程序的标志 |
|CFLAGS	|传给C编译器的标志   |
|CPPFLAGS| 传给C预处理器的标志 |
|LDFAGS	|传给连接器程序 (ld)的标志|


变量的展开:需使用`$()` `${}`

```makefile
#几个变量使用示例：  
CFLAGS	:= -g -W -std=c99 -c
LDFAGS	:= -lusrese
```








###伪目标

除了一般的文件目标体，make也允许指定伪目标。   
称其为伪目标是因为它们并不对应于实际的文件。  

如常见的 clean 

伪目标体规定了make执行的命令，但是没有依赖体，
make就认为目标体是最新的而不执行任何操作，**所以它的命令不会被自动执行**，除非明确指定。

|  目标   |    功能     |
|-------------| ------------|
|all		| 执行编译应用程序的所有工作|
|install	| 从已编译的二进制文件进行应用程序的安装|
|clean		| 将产生自源代码的二进制文件删除|
|distclean	| 删除编译过程中产生的任何文件  |
|TAGS		| 建立可供编辑器使用的标记表    |
|info		| 从Texinfo	源代码来创建GUN info 文件 |
|check		| 执行与应用程序相关的任何测试  |






####自动变量

make会设定自动变量，下面是重要的几个自动变量：

|   自动变量	|   作用		|
|---------------|---------------------------------------|
|`$@`	| 目标的文件名								|
|`$%` | 归档文件中的文件名							|
|`$<` | 第一个必要条件的文件名						|
|`$?` | 当前目标所依赖的文件列表中比当前目标文件还要新的必要条件|
|`$^` | 所有必要条件的文件名列表（并且会把重复的文件名删除） |
|`$+` | 与$^的区别是，包含重复的文件名 |
|`$(@D)` | 目标文件的目录部分(如果目标在子目录中)  |
|`$(@F)` | 目标文件的文件名部分(如果目标在子目录中)  |


与普通变量不同的是，要展开变量的值需要使用`$()`或者`${}`,自动变量则不需要这样。 
make直会在目标与条件能够进行匹配的时候，才会设置自动变量，所以自动变量只能应用在命令中。   




####特殊目标  

| 	特殊目标	 	 | 		描述			 |
|-------			-|--------			|	
|   .PHONY          |   它的所有依赖被作为伪目标      |
| .SUFFIXES			| 它的所有依赖指出了一系列在后缀规则中需要检查的后缀名|
|.DEFAULT			| ... |
| .PRECIOUS		| 它的依赖文件，当命令在执行过程中被中断时，make不会删除它们，而且如果目标的依赖文件是中间过程文件，这些文件同样不会删除|
|.INTERMEDIATE | 它的依赖文件被当作中间过程文件 |
|.SECONDARY   | 也被当作中间过程文件对待，但这些文件不会被自动删除 |
|.DELETE_ON_ERROR | 如果规则的命令执行错误，将删除已经被修改的目标文件 |
|.IGNORE  |		...  |
|更多详情见 《GNU make中文手册》  |   p42     |




###其他摘抄

下面的命令将git安装在 /usr/local/bin 中 

```shell
make prefix=/usr/local all
sudo make prefix=/usr/local install
```


